#!/usr/bin/env python3
"""
proxy_updater.py

Downloads SOCKS5 'elite' proxies from ProxyScrape, validates basic format,
optionally tests reachability, and updates Kali's proxychains configuration
(/etc/proxychains.conf or /etc/proxychains4.conf).

Usage:
    sudo python3 proxy_updater.py            # runs once, updates proxychains config
    python3 proxy_updater.py --test         # also test top N proxies by connecting
    python3 proxy_updater.py --config file  # load alternative config (see README)

Notes:
- Requires network access to fetch proxy lists and (optionally) to test proxies.
- Optional dependency for testing: requests[socks] (pip install requests[socks])
- Script will BACKUP the original proxychains conf before modifying it.
- Designed for legitimate/privacy-respecting use. Do not use for illegal activity.
"""

import argparse
import shutil
import sys
import time
from datetime import datetime
from pathlib import Path
from typing import List, Tuple, Optional

try:
    import requests
except Exception:
    requests = None  # We'll handle missing requests gracefully in the code below

# Default proxyscrape v2 API endpoint (public API; may change over time)
PROXYSCRAPE_SOCKS5_ELITE = (
    "https://api.proxyscrape.com/v2/?request=getproxies&protocol=socks5"
    "&timeout=1000&country=all&ssl=all&anonymity=elite"
)

# Files to consider for proxychains on Kali (support both proxychains and proxychains4)
PROXYCHAINS_PATHS = [
    Path("/etc/proxychains.conf"),
    Path("/etc/proxychains4.conf"),
]

BACKUP_DIR = Path("/etc/proxychains_backups")  # fallback backup dir
DEFAULT_PROXYCHAIN_TIMEOUT = 10.0  # seconds for any test connection (if used)


def fetch_proxy_list(url: str, timeout: int = 15) -> List[str]:
    if requests is None:
        raise RuntimeError("The 'requests' library is required to fetch proxy lists. Install with: pip install requests")
    resp = requests.get(url, timeout=timeout)
    resp.raise_for_status()
    text = resp.text.strip()
    # proxyscrape returns one proxy per line in ip:port format
    lines = [line.strip() for line in text.splitlines() if line.strip()]
    return lines


def filter_socks5_elite(proxies: List[str]) -> List[str]:
    # The API should already return socks5 + elite (anonymity) if URL used.
    # Here we do a basic format validation and deduplication.
    valid = []
    seen = set()
    for p in proxies:
        if ":" not in p:
            continue
        ip, port = p.split(":", 1)
        if not ip or not port.isdigit():
            continue
        entry = f"{ip}:{port}"
        if entry in seen:
            continue
        seen.add(entry)
        valid.append(entry)
    return valid


def find_proxychains_path() -> Optional[Path]:
    for p in PROXYCHAINS_PATHS:
        if p.exists():
            return p
    # If none found, default to /etc/proxychains.conf (we will create if permitted)
    return PROXYCHAINS_PATHS[0]


def backup_file(path: Path) -> Path:
    ts = datetime.utcnow().strftime("%Y%m%dT%H%M%SZ")
    BACKUP_DIR.mkdir(parents=True, exist_ok=True)
    dest = BACKUP_DIR / f"{path.name}.backup.{ts}"
    shutil.copy2(path, dest)
    return dest


def update_proxychains_file(path: Path, proxies: List[str]) -> Tuple[bool, str]:
    """
    Replaces the ProxyList section at the end of proxychains.conf with the provided proxies.
    Returns (success, message).
    """
    if not proxies:
        return False, "No proxies provided to write."

    if not path.exists():
        # create a default template if missing
        template = (
            "# proxychains configuration generated by proxy_updater.py\n\n"
            "strict_chain\nproxy_dns\nremote_dns_subnet 224\n\n[ProxyList]\n"
        )
        current = template
    else:
        current = path.read_text(encoding="utf-8", errors="ignore")

    # locate '[ProxyList]' (case-insensitive)
    lower = current.lower()
    idx = lower.find("[proxylist]")
    if idx == -1:
        # append a ProxyList section
        new_content = current.rstrip() + "\n\n[ProxyList]\n"
    else:
        # keep everything up to the ProxyList header and discard old list
        # find end of that line in original content
        start = current.lower().find("[proxylist]")
        # find next section marker after ProxyList (none expected), so we cut at header
        new_content = current[:start]
        new_content += "[ProxyList]\n"

    # add proxies - proxychains format for socks5: "socks5 <ip> <port>"
    for p in proxies:
        ip, port = p.split(":", 1)
        new_content += f"socks5 {ip} {port}\n"

    # backup existing file if it exists
    if path.exists():
        backup_file(path)

    # attempt to write (requires appropriate permissions)
    try:
        path.write_text(new_content, encoding="utf-8")
    except PermissionError as e:
        return False, f"Permission error writing {path}: {e} - try running with sudo."
    except Exception as e:
        return False, f"Failed to write {path}: {e}"

    return True, f"Wrote {len(proxies)} proxies to {path}"


def test_proxy_socks5(proxy: str, timeout: float = DEFAULT_PROXYCHAIN_TIMEOUT) -> bool:
    """
    Basic reachability test: Try to send an HTTP request via the socks5 proxy to an IP echo service.
    Requires 'requests' with socks support: pip install requests[socks]
    Returns True if we get a successful response within timeout and the remote IP differs from local IP.
    """
    if requests is None:
        print("requests not installed; skipping proxy tests.")
        return False
    try:
        import socks  # from PySocks
    except Exception:
        # PySocks may not be installed; fallback: can't test
        print("PySocks not installed (required for testing). Install with: pip install pysocks requests[socks]")
        return False

    try:
        proxies = {
            "http": f"socks5://{proxy}",
            "https": f"socks5://{proxy}",
        }
        # using httpbin or ipify could be blocked; many providers offer simple /ip endpoints
        resp = requests.get("https://httpbin.org/ip", proxies=proxies, timeout=timeout)
        if resp.status_code == 200 and resp.text:
            return True
    except Exception as e:
        # print(f"Test failed for {proxy}: {e}")
        return False
    return False


def main():
    parser = argparse.ArgumentParser(description="ProxyScrape-based SOCKS5 (elite) updater for proxychains")
    parser.add_argument("--url", help="Proxy source URL (overrides default proxyscrape)", default=PROXYSCRAPE_SOCKS5_ELITE)
    parser.add_argument("--test", action="store_true", help="Test the first N proxies for reachability (requires requests[socks])")
    parser.add_argument("--test-count", type=int, default=10, help="Number of proxies to test when --test is used")
    parser.add_argument("--no-write", action="store_true", help="Fetch and display proxies but do not modify proxychains file")
    parser.add_argument("--target", type=str, default=None, help="Path to proxychains config file to update")
    args = parser.parse_args()

    url = args.url
    print(f"[{datetime.utcnow().isoformat()}] Fetching proxies from: {url}")
    try:
        proxies_raw = fetch_proxy_list(url)
    except Exception as e:
        print(f"Failed to fetch proxy list: {e}")
        sys.exit(2)

    proxies = filter_socks5_elite(proxies_raw)
    print(f"Found {len(proxies)} candidate proxies (post-filter).")

    # optional testing
    tested = []
    if args.test:
        n = min(args.test_count, len(proxies))
        print(f"Testing first {n} proxies for reachability (this may take a while)...")
        for p in proxies[:n]:
            ok = test_proxy_socks5(p)
            print(f"  {p} -> {'OK' if ok else 'FAIL'}")
            if ok:
                tested.append(p)
        if tested:
            # prioritize tested working proxies
            proxies = tested + [p for p in proxies if p not in tested]

    if args.no_write:
        print("No-write mode: showing top 50 proxies:")
        for p in proxies[:50]:
            print(p)
        print("Done.")
        return

    # determine which proxychains file to update
    if args.target:
        target_path = Path(args.target)
    else:
        target_path = find_proxychains_path()

    if not target_path:
        print("Could not determine a proxychains config path. Please specify --target /path/to/proxychains.conf")
        sys.exit(3)

    print(f"Updating proxychains config at: {target_path}")
    ok, msg = update_proxychains_file(target_path, proxies)
    if not ok:
        print("Error:", msg)
        sys.exit(4)
    print(msg)
    print("Done. If you need to restore the previous config, check the backups in", BACKUP_DIR)


if __name__ == "__main__":
    main()
